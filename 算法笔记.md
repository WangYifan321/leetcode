# 算法笔记

## 栈

```java
Deque<Character> stack = new LinkedList<Character>();

stack.isEmpty()
stack.peek()        //拿出栈的第一个元素
stack.pop()
stack.push()
```

## Map

```java
Map<Character, Character> pairs = new HashMap<Character, Character>(){{
                put(')','(');
                put(']','[');
                put('}','{');
            }};
pairs.get()
pairs.containsKey()    
```



##  递归

https://leetcode-cn.com/problems/merge-two-sorted-lists/

```java
   public addTwoNumbers.ListNode mergeTwoLists(addTwoNumbers.ListNode l1, addTwoNumbers.ListNode l2) {
            if (l1 == null) {
                return l2;
            } else if (l2 == null) {
                return l1;
            } else if (l1.val < l2.val) {
                l1.next = mergeTwoLists(l1.next, l2);
                return l1;
            } else {
                l2.next = mergeTwoLists(l1, l2.next);
                return l2;
            }

        }
```

## 动态规划

https://leetcode-cn.com/problems/maximum-subarray/solution/zui-da-zi-xu-he-by-leetcode-solution/

**对于求一个数组中连续区间的最大值，可以先求出前几个值若为负的则舍弃，正的话就加上当前值，形成一个动态规划的数组，求数组中的最大值即可**

```java
class Solution {
    public int maxSubArray(int[] nums) {
       if(nums.length == 1){
           return nums[0];
       }else{
           int pre=0;
           int max=nums[0];
           for(int x:nums){
              pre = Math.max(pre+x,x);
              max = Math.max(max,pre);
           }
           return max;
       }
       
    }
}
```

动态规划转移方程：
f(i)=max{f(i−1)+nums[i],nums[i]}

**爬楼梯**

https://leetcode-cn.com/problems/climbing-stairs/submissions/

也可以用动态规划求解，n阶楼梯的到达种数一定是n-1加上n-2，因为到达此楼梯只能是由前一个或前两个楼梯跨越过来



## 树

二叉树的中序遍历

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
        List<Integer> result = new ArrayList<>();
    public List<Integer> inorderTraversal(TreeNode root) {
       
      middle_order(root);
      return result;
        
    }
    public void middle_order(TreeNode root){
        if(root == null){
            return;
        }
        middle_order(root.left);
        result.add(root.val);
        middle_order(root.right);
    }
}
```

检验是否是对称二叉树

```java
//递归
class Solution {
    public boolean isSymmetric(TreeNode root) {
      return check(root.left,root.right);
    }
    public boolean check(TreeNode p, TreeNode q){
        if(p == null && q == null){
            return true;
        }else if(p == null || q==null){
            return false;
        }
        return p.val == q.val && check(p.left,q.right) && check(p.right,q.left);
    }
}
//非递归
class Solution {
        public boolean isSymmetric(TreeNode root) {
            return check(root, root);
        }

        public boolean check(TreeNode p,TreeNode q){
            Queue<TreeNode> queue = new LinkedList<>();
            queue.offer(p);
            queue.offer(q);
            while(!queue.isEmpty()){
                TreeNode m = queue.poll();
                TreeNode n = queue.poll();
                if(m == null && n == null){
                    continue;
                }
                if(m == null || n == null || m.val != n.val){
                    return false;
                }
                queue.offer(m.left);
                queue.offer(n.right);
                queue.offer(m.right);
                queue.offer(n.left);
            }
            return true;
        }

    }
```



