# 算法笔记

## 栈

```java
Deque<Character> stack = new LinkedList<Character>();

stack.isEmpty()
stack.peek()        //拿出栈的第一个元素
stack.pop()
stack.push()
```

## Map

```java
Map<Character, Character> pairs = new HashMap<Character, Character>(){{
                put(')','(');
                put(']','[');
                put('}','{');
            }};
pairs.get()
pairs.containsKey()    
```



##  递归

https://leetcode-cn.com/problems/merge-two-sorted-lists/

```java
   public addTwoNumbers.ListNode mergeTwoLists(addTwoNumbers.ListNode l1, addTwoNumbers.ListNode l2) {
            if (l1 == null) {
                return l2;
            } else if (l2 == null) {
                return l1;
            } else if (l1.val < l2.val) {
                l1.next = mergeTwoLists(l1.next, l2);
                return l1;
            } else {
                l2.next = mergeTwoLists(l1, l2.next);
                return l2;
            }

        }
```

## 动态规划

https://leetcode-cn.com/problems/maximum-subarray/solution/zui-da-zi-xu-he-by-leetcode-solution/

**对于求一个数组中连续区间的最大值，可以先求出前几个值若为负的则舍弃，正的话就加上当前值，形成一个动态规划的数组，求数组中的最大值即可**

```java
class Solution {
    public int maxSubArray(int[] nums) {
       if(nums.length == 1){
           return nums[0];
       }else{
           int pre=0;
           int max=nums[0];
           for(int x:nums){
              pre = Math.max(pre+x,x);
              max = Math.max(max,pre);
           }
           return max;
       }
       
    }
}
```

动态规划转移方程：
f(i)=max{f(i−1)+nums[i],nums[i]}

**爬楼梯**

https://leetcode-cn.com/problems/climbing-stairs/submissions/

也可以用动态规划求解，n阶楼梯的到达种数一定是n-1加上n-2，因为到达此楼梯只能是由前一个或前两个楼梯跨越过来

买卖股票的最佳时机

```java
//https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/
public class buyAndSellStock {
     class Solution1 {
        public int maxProfit(int prices[]) {
            int maxprofit = 0;
            for (int i = 0; i < prices.length - 1; i++) {
                for (int j = i + 1; j < prices.length; j++) {
                    int profit = prices[j] - prices[i];
                    if (profit > maxprofit) {
                        maxprofit = profit;
                    }
                }
            }
            return maxprofit;
        }
    }
    public class Solution2 {
        public int maxProfit(int prices[]) {
            int minprice = Integer.MAX_VALUE;
            int maxprofit = 0;
            for (int i = 0; i < prices.length; i++) {
                if (prices[i] < minprice) {
                    minprice = prices[i];
                } else if (prices[i] - minprice > maxprofit) {
                    maxprofit = prices[i] - minprice;
                }
            }
            return maxprofit;
        }
    }

    class Solution3 {
        public int maxProfit(int[] prices) {
            int len = prices.length;
            int res = 0;
            // 前一天卖出可以获得的最大利润
            int pre = 0;
            for (int i = 1; i < len; i++) {
                // 利润差
                int diff = prices[i] - prices[i - 1];
                // 状态转移方程：第i天卖出可以获得的最大利润 = 第i-1天卖出的最大利润 + 利润差
                pre = Math.max(pre + diff, 0);
                res = Math.max(res, pre);
            }
            return res;
        }
    }
}

```



## 树

二叉树的中序遍历

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
        List<Integer> result = new ArrayList<>();
    public List<Integer> inorderTraversal(TreeNode root) {
       
      middle_order(root);
      return result;
        
    }
    public void middle_order(TreeNode root){
        if(root == null){
            return;
        }
        middle_order(root.left);
        result.add(root.val);
        middle_order(root.right);
    }
}
```

检验是否是对称二叉树

```java
//递归
class Solution {
    public boolean isSymmetric(TreeNode root) {
      return check(root.left,root.right);
    }
    public boolean check(TreeNode p, TreeNode q){
        if(p == null && q == null){
            return true;
        }else if(p == null || q==null){
            return false;
        }
        return p.val == q.val && check(p.left,q.right) && check(p.right,q.left);
    }
}
//非递归
class Solution {
        public boolean isSymmetric(TreeNode root) {
            return check(root, root);
        }

        public boolean check(TreeNode p,TreeNode q){
            Queue<TreeNode> queue = new LinkedList<>();
            queue.offer(p);
            queue.offer(q);
            while(!queue.isEmpty()){
                TreeNode m = queue.poll();
                TreeNode n = queue.poll();
                if(m == null && n == null){
                    continue;
                }
                if(m == null || n == null || m.val != n.val){
                    return false;
                }
                queue.offer(m.left);
                queue.offer(n.right);
                queue.offer(m.right);
                queue.offer(n.left);
            }
            return true;
        }

    }
```



## 异或

同为0，不同为1.具有传递性与符合交换律

```java
/*
给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

说明：

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

示例 1:

输入: [2,2,1]
输出: 1
示例 2:

输入: [4,1,2,1,2]
输出: 4

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/single-number
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

*/
class Solution {
    public int singleNumber(int[] nums) {
       if(nums == null){
           return 0;
       }
       int single=0;
       for(int num : nums){
           single ^= num;
       }
       return single;
    }
}
```

## Set

**利用set集合的不重复性，可以使用hashset来判断一个链表是否有环**

判断一个链表是否有环还可以用Floyd 判圈算法。

https://leetcode-cn.com/problems/linked-list-cycle/solution/huan-xing-lian-biao-by-leetcode-solution/

```java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution1 {
    public boolean hasCycle(ListNode head) {
        Set<ListNode> seen = new HashSet<>();
        while(head != null){
            if(!seen.add(head)){
                return true;
            }
            head = head.next;
        }
        return false;
    }
}

public class Solution2 {
    public boolean hasCycle(ListNode head) {
        if(head == null || head.next == null){
            return false;
        }
        ListNode slow = head;
        ListNode fast = head.next;
        while(slow != fast){
            if(fast==null || fast.next==null){
                return false;
            }
            slow = slow.next;
            fast = fast.next.next;
        }
        return true;
    }
}
```

## 滑动窗口

无重复字符的最长子串

每一个字符挨着往后遍历，找到最长的无重复子串。设置一个左指针一个右指针

https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
       int len = s.length();
       Set<Character> set = new HashSet<>();
       int right = 0, max = 0;
       for(int i=0; i<len; i++){
           /*因为是算出来的最长子串所以必定无重复的，可以重复利用提高算法的效率。因此只需要把前一个字符从集合中删去，下一个字符就变成了第一个字符，后面的也不重复*/
           if(i != 0){
               set.remove(s.charAt(i-1));
           }
           while(right < len && !set.contains(s.charAt(right))){
               set.add(s.charAt(right));
               right++;
           }

           max = Math.max(max,right-i);
       }
       return max;

    }
}
```



